Я вважаю, що продукти потрiбно реалiзуваты згiдно за паттерном <<Фабричний метод>>
— це породжувальний патерн проектування, який визначає загальний інтерфейс для створення об’єктів у суперкласі, 
дозволяючи підкласам змінювати тип створюваних об’єктів.

Тобто буде класс Creator який буде створювати новi види продукту за допомогою спiльного iнтрефейсу
Product, а його вже будуть реалiзувати необхiднi нам продукти:
- класи продуктiв будуть лише Data классами вони будуь зберiгати стан когжного окремого продукту згiдно 

також треба зауважити, що для створення кожного новогу продукту потрiбен клас який буде наслыдуватись вiд Creator
та буде створювати потрiбнi нам класи продуктiв.

Тим самим клас Storage буде зберiгати всi продукти за допомогою iнтерфейсу Product.
та буде мати весь необхiдний функцiонал щоб бути обгорткою над IList<IProduct> щоб 
(додавати, видаляти, отримувати, тощо необхiднi продукти)

Також нам буде потрiбен клас ProductService
 - який буде корегувати цiну для всiх продуктiв
 - окремих продуктiв
 - збiльшувати/зменшувати кiлькiсть продуктiв на складi
Product(який матимеметод змени цiни), а його вже будуть реалiзувати необхiднi нам продукти

також треба зауважити, що для створення кожного новогу продукту потрiбен клас який буде наслыдуватись вiд Creator
та буде створюваты потрiбны нам класи продуктiвю

Тим самим клас Storage буде зберiгати все продукти за допомогою iнтерфейсу Product.
та буде мати весь необхiдний функцiонал щоб бути обгорткою над Ilist щоб (додаваьти, отримувати тощо необхiднi продукти)

В разi узагальнення ми можемо вказати Interface Product тобто у списку ми отримаемо лише продути якi наслiдуються вiд данного
iнтерфесу..

на мою думку така структура проекту буде:
 - оптимальною для росширення бази продуктiв
 - зможе покрити безлiч нових утворенних продуктiв
 - Позбавляє клас від прив’язки до конкретних класів продуктів.
 - спростить підтримку коду.
 - Реалізує принцип відкритості/закритості.
